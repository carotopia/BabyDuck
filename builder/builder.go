package builder

import (
	"BabyDuckCompiler/grammar"
	"BabyDuckCompiler/symbols"
	"fmt"
)

// DirectoryBuilder  inherits base listener generated by ANTRL
// Gets the main table of functions and variables
// Errors returns a list of semantic errors
// If true returns info for debug
type DirectoryBuilder struct {
	grammar.BaseBabyDuckListener
	Directory *symbols.FunctionDirectory
	Errors    []string
	Debug     bool
}

// NewDirectoryBuilder creates and initializes a new DirectoryBuilder
// Returns a pointer to the new directory
func NewDirectoryBuilder(debug bool) *DirectoryBuilder {
	return &DirectoryBuilder{
		Directory: symbols.NewFunctionDirectory(),
		Errors:    []string{},
		Debug:     debug,
	}
}

// EnterFunc obtains the name of the functions and the checks if it exists in the current scope
// Makes push to function name, now is in the scope
func (d *DirectoryBuilder) EnterFunc(ctx *grammar.FuncContext) {
	functionName := ctx.ID().GetText()
	fmt.Printf("Function '%s' already declared in current scope\n", functionName)
	err := d.Directory.AddFunction(functionName)
	if err != nil {
		d.Errors = append(d.Errors, err.Error())
	}
	d.Directory.CurrentScope = append(d.Directory.CurrentScope, functionName)
}

// ExitFunctionDeclaration pops out of the functions and returns to the scope before
func (d *DirectoryBuilder) ExitFunctionDeclaration(ctx *grammar.FuncContext) {
	d.Directory.CurrentScope = d.Directory.CurrentScope[:len(d.Directory.CurrentScope)-1]
}

// ExitVar_when exits a new declaration, tries to add every declaration to the current scope
// If it already existed saves the error
func (d *DirectoryBuilder) ExitVar_decl(ctx *grammar.Var_declContext) {
	variableType := ctx.Type_().GetText()

	for _, idNode := range ctx.Id_list().AllID() {
		variableName := idNode.GetText()
		err := d.Directory.AddVariable(variableName, variableType)
		if err != nil {
			// Variable already defined in current scope"
			d.Errors = append(d.Errors, err.Error())
		}
	}
}

// EnterParam when entering a new function tries to add it to the current scope

func (d *DirectoryBuilder) EnterParam(ctx *grammar.ParamContext) {
	paramName := ctx.ID().GetText()
	paramType := ctx.Type_().GetText()

	err := d.Directory.AddVariable(paramName, paramType)
	if err != nil {
		// Parameter already defined in current function
		d.Errors = append(d.Errors, err.Error())
	}
}

// ExitAssign checks that if you want to use a variable i wnt to make sure it was already declared
func (d *DirectoryBuilder) ExitAssign(ctx *grammar.AssignContext) {
	variableName := ctx.ID().GetText()
	scopes := d.Directory.CurrentScope

	err := d.Directory.ValidateVariable(scopes, variableName)
	if err != nil {
		d.Errors = append(d.Errors, err.Error())
	}
}
func (d *DirectoryBuilder) ExitExpression(ctx *grammar.ExpressionContext) {
	// Valida los lados de la comparación
	if ctx.Relational() != nil {
		left := ctx.Exp()
		right := ctx.Relational().Exp()

		d.validateExp(left)
		d.validateExp(right)
	}
}

func (d *DirectoryBuilder) validateExp(exp grammar.IExpContext) {
	if exp == nil {
		return
	}

	for _, term := range exp.AllTerm() {
		d.validateTerm(term)
	}
}

func (d *DirectoryBuilder) validateTerm(ctx grammar.ITermContext) {
	for _, factor := range ctx.AllFactor() {
		d.validateFactor(factor)
	}
}
func (d *DirectoryBuilder) validateFactor(ctx grammar.IFactorContext) {
	if ctx.Parexpr() != nil {
		d.validateExpression(ctx.Parexpr().Expression())
	} else if ctx.Factorsign() != nil {
		d.validateFactorsign(ctx.Factorsign())
	}
}

func (d *DirectoryBuilder) validateFactorsign(ctx grammar.IFactorsignContext) {
	val := ctx.Value()
	if val.ID() != nil {
		varName := val.ID().GetText()
		scopes := d.Directory.CurrentScope
		err := d.Directory.ValidateVariable(scopes, varName)
		if err != nil {
			d.Errors = append(d.Errors, fmt.Sprintf("variable '%s' is not declared", varName))
		}
	}
}

func (d *DirectoryBuilder) validateExpression(ctx grammar.IExpressionContext) {
	exp := ctx.Exp()
	if exp != nil {
		d.validateExp(exp)
	}

	rel := ctx.Relational()
	if rel != nil {
		d.validateRelational(rel)
	}
}

func (d *DirectoryBuilder) validateRelational(ctx grammar.IRelationalContext) {
	exp := ctx.Exp()
	if exp != nil {
		d.validateExp(exp)
	}
}

func (d *DirectoryBuilder) validateValue(ctx grammar.IValueContext) {
	id := ctx.ID()
	if id != nil {
		name := id.GetText()
		scopes := d.Directory.CurrentScope
		err := d.Directory.ValidateVariable(scopes, name)
		if err != nil {
			d.Errors = append(d.Errors, err.Error())
		}
	}
}

func (d *DirectoryBuilder) ExitPrint_stmt(ctx *grammar.Print_stmtContext) {
	for _, pexpr := range ctx.AllPrintexpr() {
		if pexpr.STRING() != nil {
			continue
		}

		exp := pexpr.Exp()
		if exp != nil {
			d.validateExp(exp)
		}
	}
}

func (d *DirectoryBuilder) ExitCycle(ctx *grammar.CycleContext) {
	if ctx.Expression() != nil {
		d.validateExpression(ctx.Expression())
	}
}
func (d *DirectoryBuilder) ExitCondition(ctx *grammar.ConditionContext) {
	cond := ctx.Expression()

	if cond != nil {
		d.validateExpression(cond)
	}
}

func (d *DirectoryBuilder) ExitF_call(ctx *grammar.F_callContext) {
	funcName := ctx.ID().GetText()
	funcDir := d.Directory.Directory

	// 1. Verifica si existe la función
	paramTable, exists := funcDir[funcName]
	if !exists {
		d.Errors = append(d.Errors, fmt.Sprintf("error: function '%s' not defined", funcName))
		return
	}

	// 2. Cuenta los argumentos enviados
	argCount := 0
	if ctx.Arg_list() != nil {
		for _, exp := range ctx.Arg_list().AllExpression() {
			d.validateExpression(exp)
			argCount++
		}
	}

	// 3. Compara cantidad de argumentos enviados con los declarados
	paramCount := len(paramTable) // parámetros están guardados como variables dentro del scope de la función

	if argCount != paramCount {
		d.Errors = append(d.Errors,
			fmt.Sprintf("error: function '%s' expects %d arguments, got %d", funcName, paramCount, argCount))
	}
}
