package builder

import (
	"BabyDuckCompiler/grammar"
	"BabyDuckCompiler/quads"
	"BabyDuckCompiler/semantic"
	"BabyDuckCompiler/symbols"
	"fmt"
	_ "strconv"
)

// DirectoryBuilder  inherits base listener generated by ANTRL
// Gets the main table of functions and variables
// Errors returns a list of semantic errors
// If true returns info for debug
type DirectoryBuilder struct {
	*grammar.BaseBabyDuckListener // ✅ esto debe ser un *puntero*, no solo `grammar.BaseBabyDuckListener`

	Directory     *symbols.FunctionDirectory
	Errors        []string
	Debug         bool
	OperatorStack *quads.OperatorStack
	OperandStack  *quads.Stack
	TypeStack     *quads.TypeStack
	QuadQueue     *quads.QuadrupleQueue
	PendingJumps  []int
}

// NewDirectoryBuilder creates and initializes a new DirectoryBuilder
// Returns a pointer to the new directory
func NewDirectoryBuilder(debug bool) *DirectoryBuilder {
	return &DirectoryBuilder{
		BaseBabyDuckListener: &grammar.BaseBabyDuckListener{}, // ✅ aquí inicializas el campo embebido como puntero
		Directory:            symbols.NewFunctionDirectory(),
		Errors:               []string{},
		Debug:                debug,
		OperatorStack:        quads.NewOperatorStack(),
		OperandStack:         quads.NewOperandStack(),
		TypeStack:            quads.NewTypeStack(),
		QuadQueue:            quads.NewQuadrupleQueue(),
		PendingJumps:         []int{},
	}
}

// EnterFunc obtains the name of the functions and the checks if it exists in the current scope
// Makes push to function name, now is in the scope
func (d *DirectoryBuilder) EnterFunc(ctx *grammar.FuncContext) {
	functionName := ctx.ID().GetText()

	// Recolectar parámetros
	var params []symbols.Variable
	if ctx.Param_list() != nil {
		paramListCtx := ctx.Param_list().(*grammar.Param_listContext)
		for _, paramCtx := range paramListCtx.AllParam() {
			param := paramCtx.(*grammar.ParamContext)
			varType := param.Type_().GetText()
			params = append(params, symbols.Variable{
				Type: varType,
			})
		}
	}

	err := d.Directory.AddFunction(functionName, params)
	if err != nil {
		d.addErrorOnce(err.Error())
	}

	// Agregar a scope
	d.Directory.CurrentScope = append(d.Directory.CurrentScope, functionName)
}

// ExitFunctionDeclaration pops out of the functions and returns to the scope before
func (d *DirectoryBuilder) ExitFunctionDeclaration(ctx *grammar.FuncContext) {
	d.Directory.CurrentScope = d.Directory.CurrentScope[:len(d.Directory.CurrentScope)-1]
}

// ExitVar_when exits a new declaration, tries to add every declaration to the current scope
// If it already existed saves the error
func (d *DirectoryBuilder) ExitVar_decl(ctx *grammar.Var_declContext) {
	variableType := ctx.Type_().GetText()

	for _, idToken := range ctx.Id_list().AllID() {
		varName := idToken.GetText()

		err := d.Directory.AddVariable(varName, variableType)
		if err != nil {
			d.addErrorOnce(err.Error())
			continue
		}

		if d.Debug {
			fmt.Printf("[Debug] Variable declarada: %s (%s)\n", varName, variableType)
		}
	}
}
func (d *DirectoryBuilder) addErrorOnce(msg string) {
	for _, e := range d.Errors {
		if e == msg {
			return // Ya existe, no agregues duplicados
		}
	}
	d.Errors = append(d.Errors, msg)
}

// EnterParam when entering a new function tries to add it to the current scope
func (d *DirectoryBuilder) EnterParam(ctx *grammar.ParamContext) {
	paramName := ctx.ID().GetText()
	paramType := ctx.Type_().GetText()

	err := d.Directory.AddVariable(paramName, paramType)
	if err != nil {
		// Parameter already defined in current function
		d.addErrorOnce(err.Error())
	}
}

// ExitAssign checks that if you want to use a variable i wnt to make sure it was already declared
func (d *DirectoryBuilder) ExitAssign(ctx *grammar.AssignContext) {
	variableName := ctx.ID().GetText()

	// ✅ Validar existencia
	err := d.Directory.ValidateVariable(variableName)
	if err != nil {
		d.addErrorOnce(err.Error())
		return
	}

	// ✅ La expresión ya fue evaluada antes de llegar aquí, solo hacemos pop
	rightOperand, ok1 := d.OperandStack.Pop()
	rightType, ok2 := d.TypeStack.Pop()
	if !ok1 || !ok2 {
		d.Errors = append(d.Errors, "Error al obtener el valor de la expresión en la asignación")
		return
	}

	// ✅ Buscar la variable destino
	variable, exists := d.Directory.FindVariableDeep(variableName)
	if !exists {
		d.Errors = append(d.Errors, fmt.Sprintf("Variable '%s' no encontrada", variableName))
		return
	}

	// ✅ Validar tipo con el cubo semántico
	resultType, ok := semantic.Cube.GetResultType(rightType, rightType, "=")
	if !ok || resultType != variable.Type {
		d.Errors = append(d.Errors, fmt.Sprintf("Tipo incompatible en asignación: %s = %s", variable.Type, rightType))
		return
	}

	// ✅ Generar cuádruplo: = t1 _ a
	d.QuadQueue.Add("=", rightOperand, "", variable.MemoryAddress)
}

func (d *DirectoryBuilder) validateTerm(ctx grammar.ITermContext) {
	for _, factor := range ctx.AllFactor() {
		d.validateFactor(factor)
	}
}

func (d *DirectoryBuilder) validateFactor(ctx grammar.IFactorContext) {
	if ctx.Expression() != nil {
		// Caso: ( expression )
		d.validateExpression(ctx.Expression())
	} else if ctx.Value() != nil {
		// Caso: (+|-) value
		// Puedes validar el signo si quieres con ctx.Addop()
		d.validateValue(ctx.Value())
	}
}

func (d *DirectoryBuilder) validateExpression(exp grammar.IExpressionContext) {
	if exp == nil {
		return
	}

	relExpr := exp.Rel_expr()
	if relExpr == nil {
		return
	}

	// Validar la expresión relacional
	d.validateRelExpr(relExpr)
}

func (d *DirectoryBuilder) validateAddExpr(add grammar.IAdd_exprContext) {
	if add == nil {
		return
	}

	terms := add.AllTerm()
	for _, term := range terms {
		d.validateTerm(term)
	}
}
func (d *DirectoryBuilder) validateRelExpr(ctx grammar.IRel_exprContext) {
	if ctx == nil {
		return
	}

	// Validar el primer add_expr (siempre está presente)
	left := ctx.Add_expr(0)
	if left != nil {
		d.validateAddExpr(left)
	}

	// Si hay relop y un segundo add_expr, validarlo también
	if ctx.Relop() != nil && len(ctx.AllAdd_expr()) > 1 {
		right := ctx.Add_expr(1)
		d.validateAddExpr(right)
	}
}

func (d *DirectoryBuilder) validateValue(ctx grammar.IValueContext) {
	id := ctx.ID()
	if id != nil {
		name := id.GetText()
		err := d.Directory.ValidateVariable(name)
		if err != nil {
			d.addErrorOnce(err.Error())
			return
		}
		// Si quieres trabajar con la variable (por ejemplo, su dirección):
		_, _ = d.Directory.FindVariableDeep(name)

	}
}

func (d *DirectoryBuilder) ExitPrint_stmt(ctx *grammar.Print_stmtContext) {
	for _, pexpr := range ctx.AllPrintexpr() {
		// Caso: imprimir string literal
		if pexpr.STRING() != nil {
			stringValue := pexpr.STRING().GetText()
			d.QuadQueue.Add("print", stringValue, "", "")
			continue
		}

		// Caso: imprimir una expresión
		if pexpr.Expression() != nil {
			d.validateExpression(pexpr.Expression())

			// Pop del resultado de la expresión
			value, _ := d.OperandStack.Pop()
			d.TypeStack.Pop() // ya no lo usamos

			d.QuadQueue.Add("print", value, "", "")
		}
	}
}

func (d *DirectoryBuilder) ExitCycle(ctx *grammar.CycleContext) {
	if ctx.Expression() != nil {
		d.validateExpression(ctx.Expression())
	}
}

// Esta función debería llamarse al final de la estructura if-else
// (posiblemente en un método ExitIf o similar, dependiendo de tu gramática)
func (d *DirectoryBuilder) ExitCondition(ctx *grammar.ConditionContext) {
	// Validar la expresión booleana
	d.validateExpression(ctx.Expression())

	condResult, ok := d.OperandStack.Pop()
	if !ok {
		d.Errors = append(d.Errors, "Condición sin resultado")
		return
	}

	condType, ok := d.TypeStack.Pop()
	if !ok || condType != "bool" {
		d.Errors = append(d.Errors, fmt.Sprintf("Condición no booleana: %v", condType))
		return
	}

	// Generar GOTOF con destino pendiente
	gotoF := d.QuadQueue.Size()
	d.QuadQueue.Add("GOTOF", condResult, nil, nil)

	// Guardar para ExitElse_part
	d.PendingJumps = append(d.PendingJumps, gotoF)
}

// ExitF_call checks if the function exists and if the number of arguments is correct
func (d *DirectoryBuilder) ExitF_call(ctx *grammar.F_callContext) {
	// Obtener el nombre de la función desde el contexto
	funcName := ctx.ID().GetText()

	// Obtener el número de argumentos
	numArgs := 0
	if ctx.Arg_list() != nil {
		// Recorrer todas las expresiones dentro de Arg_list
		for _ = range ctx.Arg_list().(*grammar.Arg_listContext).AllExpression() {
			numArgs++
		}
	}

	// Validar la llamada de la función con la cantidad de argumentos
	if err := d.Directory.ValidateFunctionCall(funcName, numArgs); err != nil {
		// Si hay un error en la validación, agregarlo a la lista de errores
		d.addErrorOnce(err.Error())
	}
}
func (d *DirectoryBuilder) ExitFactor(ctx *grammar.FactorContext) {
	// Caso 1: (expression)
	if ctx.Expression() != nil {
		// Ya fue validada por otro Exit
		return
	}

	// Caso 2: (addop)? value
	valCtx := ctx.Value()
	if valCtx == nil {
		d.Errors = append(d.Errors, "Error: factor sin valor")
		return
	}

	// Manejar signo, si existe
	if ctx.Addop() != nil {
		sign := ctx.Addop().GetText()
		val, ok := d.OperandStack.Pop()
		if !ok {
			d.Errors = append(d.Errors, "Error: pila de operandos vacía al aplicar signo")
			return
		}
		// El valor puede ser una constante, variable (dirección) o temporal.
		// Si es dirección, puedes necesitar lógica extra para manejar el signo en generación de código.
		// Para constantes: solo anteponer el signo al string (por ejemplo, "-1").
		// Para direcciones de variable, puedes decidir no hacer nada o manejarlo según tu arquitectura.

		// Por ahora, asumimos que solo aplica a constantes:
		d.OperandStack.Push(sign + fmt.Sprint(val))
		// El tipo ya está correcto en d.TypeStack, no lo cambias.
	}
	// Si no hay signo, no hagas nada aquí: ExitValue ya hizo el push.
}

func (d *DirectoryBuilder) ExitTerm(ctx *grammar.TermContext) {
	mulops := ctx.AllMulop()

	for range mulops {
		// Extraer operador del stack (agregado en EnterMulop)
		op, ok := d.OperatorStack.Pop()
		if !ok {
			d.Errors = append(d.Errors, "Error: operador faltante en pila (mulop)")
			return
		}

		// Extraer operandos
		right, ok1 := d.OperandStack.Pop()
		left, ok2 := d.OperandStack.Pop()
		if !ok1 || !ok2 {
			d.Errors = append(d.Errors, "Error: operandos insuficientes para operación mulop")
			return
		}

		// Extraer tipos
		rightType, ok1 := d.TypeStack.Pop()
		leftType, ok2 := d.TypeStack.Pop()
		if !ok1 || !ok2 {
			d.Errors = append(d.Errors, "Error: tipos insuficientes en pila de tipos")
			return
		}

		// Validar tipos en el cubo semántico
		resultType, ok := semantic.Cube.GetResultType(leftType, rightType, op)
		if !ok || resultType == "error" {
			d.Errors = append(d.Errors,
				fmt.Sprintf("Tipo incompatible: %s %s %s", leftType, op, rightType))
			return
		}

		// Crear variable temporal
		tempVar := d.Directory.NewTempVar("t")
		d.QuadQueue.Add(op, left, right, tempVar.MemoryAddress)

		// Empujar resultado
		d.OperandStack.Push(tempVar.MemoryAddress)
		d.TypeStack.Push(resultType)
	}
}
func (d *DirectoryBuilder) EnterMulop(ctx *grammar.MulopContext) {
	op := ctx.GetText() // Devuelve "*" o "/"
	d.OperatorStack.Push(op)
}

func (d *DirectoryBuilder) ExitAdd_expr(ctx *grammar.Add_exprContext) {
	addops := ctx.AllAddop()

	for range addops {
		// 1. Obtener el operador
		op, ok := d.OperatorStack.Pop()
		if !ok {
			d.Errors = append(d.Errors, "Error: falta operador en pila (addop)")
			return
		}

		// 2. Obtener operandos
		right, ok1 := d.OperandStack.Pop()
		left, ok2 := d.OperandStack.Pop()
		if !ok1 || !ok2 {
			d.Errors = append(d.Errors, "Error: operandos insuficientes para operación")
			return
		}

		// 3. Obtener tipos
		rightType, ok1 := d.TypeStack.Pop()
		leftType, ok2 := d.TypeStack.Pop()
		if !ok1 || !ok2 {
			d.Errors = append(d.Errors, "Error: tipos insuficientes en pila")
			return
		}

		// 4. Validar tipos con el cubo semántico
		resultType, ok := semantic.Cube.GetResultType(leftType, rightType, op)
		if !ok || resultType == "error" {
			d.Errors = append(d.Errors, fmt.Sprintf("Tipo incompatible: %s %s %s", leftType, op, rightType))
			return
		}

		// 5. Generar variable temporal y cuádruplo
		tempVar := d.Directory.NewTempVar("t")
		d.QuadQueue.Add(op, left, right, tempVar.MemoryAddress)

		d.OperandStack.Push(tempVar.MemoryAddress)
		d.TypeStack.Push(resultType)
	}
}
func (d *DirectoryBuilder) EnterAddop(ctx *grammar.AddopContext) {
	op := ctx.GetText() // "+" o "-"
	d.OperatorStack.Push(op)
}

func (d *DirectoryBuilder) ExitValue(ctx *grammar.ValueContext) {

	if ctx.ID() != nil {
		name := ctx.ID().GetText()

		variable, found := d.Directory.FindVariableDeep(name)

		if !found {
			d.Errors = append(d.Errors, fmt.Sprintf("Variable '%s' no definida", name))
			return
		}

		d.OperandStack.Push(variable.MemoryAddress)
		d.TypeStack.Push(variable.Type)

	} else if ctx.Constant() != nil {
		val := ctx.Constant().GetText()
		typ := semantic.InferTypeFromConstant(val)

		// Aquí puedes manejar los constantes como literales directos
		d.OperandStack.Push(val)
		d.TypeStack.Push(typ)
	}
}

func (d *DirectoryBuilder) EnterTerm(ctx *grammar.TermContext) {
	if len(ctx.AllMulop()) > 0 {
		for _, op := range ctx.AllMulop() {
			d.OperatorStack.Push(op.GetText())
		}
	}
}
func (d *DirectoryBuilder) EnterExpression(ctx *grammar.ExpressionContext) {
	if d.Debug {
		fmt.Println("[Debug] Entrando a expresión")
	}
}

func (d *DirectoryBuilder) ExitProgram(ctx *grammar.ProgramContext) {
	fmt.Println("=== Cuádruplos generados ===")
	for i, quad := range d.QuadQueue.Items {
		fmt.Printf("%d: (%s, %v, %v, %v)\n", i, quad.Operator, quad.LeftOperand, quad.RightOperand, quad.Result)
	}
}

func (d *DirectoryBuilder) ExitBody(ctx *grammar.BodyContext) {
	parentCtx := ctx.GetParent()
	if condCtx, ok := parentCtx.(*grammar.ConditionContext); ok {
		// ¿Hay else?
		hasElse := false
		elseStart := d.QuadQueue.Size() // Donde inicia el else (por si hay)
		if condCtx.Else_part() != nil {
			elsePartCtx := condCtx.Else_part().(*grammar.Else_partContext)
			if elsePartCtx.Body() != nil {
				hasElse = true
			}
		}

		if hasElse {
			// Si hay else, genera GOTO (pendiente)
			gotoEndQuad := d.QuadQueue.Add("GOTO", "", "", "")

			// Rellenar GOTOF para saltar al inicio del else
			if len(d.PendingJumps) > 0 {
				lastGotoFIndex := d.PendingJumps[len(d.PendingJumps)-1]
				// Aquí elseStart es donde inicia el else
				d.QuadQueue.UpdateResult(lastGotoFIndex, elseStart)
				// Quitar el GOTOF ya rellenado
				d.PendingJumps = d.PendingJumps[:len(d.PendingJumps)-1]
				// Guardar el nuevo GOTO pendiente
				d.PendingJumps = append(d.PendingJumps, gotoEndQuad)
			}
		} else {
			// Si no hay else, rellena el GOTOF para saltar al final del if
			if len(d.PendingJumps) > 0 {
				lastGotoFIndex := d.PendingJumps[len(d.PendingJumps)-1]
				end := d.QuadQueue.Size()
				d.QuadQueue.UpdateResult(lastGotoFIndex, end)
				d.PendingJumps = d.PendingJumps[:len(d.PendingJumps)-1]
			}
		}
	}
}

func (d *DirectoryBuilder) ExitElse_part(ctx *grammar.Else_partContext) {
	if len(d.PendingJumps) == 0 {
		// No hay salto pendiente; simplemente no hagas nada (no es un error fatal).
		return
	}

	// Tomar el índice del último GOTO (que apunta al final del if-else)
	gotoEndIndex := d.PendingJumps[len(d.PendingJumps)-1]
	d.PendingJumps = d.PendingJumps[:len(d.PendingJumps)-1]

	// Rellenar el salto para que apunte justo después del else
	end := d.QuadQueue.Size()
	d.QuadQueue.FillJump(gotoEndIndex, end)
}

func (d *DirectoryBuilder) FinalizeIf() {
	if len(d.PendingJumps) == 0 {
		return
	}
	last := len(d.PendingJumps) - 1
	gotoEndIndex := d.PendingJumps[last]
	d.PendingJumps = d.PendingJumps[:last]

	end := d.QuadQueue.Size()
	d.QuadQueue.FillJump(gotoEndIndex, end)
}

func (d *DirectoryBuilder) ExitRel_expr(ctx *grammar.Rel_exprContext) {
	// Solo hay operación si hay relop (es opcional en la gramática)
	if ctx.Relop() == nil {
		return
	}

	// Extraer operandos
	rightOperand, ok1 := d.OperandStack.Pop()
	leftOperand, ok2 := d.OperandStack.Pop()
	if !ok1 || !ok2 {
		d.Errors = append(d.Errors, "Error: operandos insuficientes en expresión relacional")
		return
	}

	// Extraer tipos
	rightType, ok1 := d.TypeStack.Pop()
	leftType, ok2 := d.TypeStack.Pop()
	if !ok1 || !ok2 {
		d.Errors = append(d.Errors, "Error: tipos insuficientes en expresión relacional")
		return
	}

	// Operador
	op := ctx.Relop().GetText()

	// Validar tipos
	resultType, ok := semantic.Cube.GetResultType(leftType, rightType, op)
	if !ok || resultType == "error" {
		d.Errors = append(d.Errors,
			fmt.Sprintf("Error: Tipos incompatibles para operación relacional: %s %s %s", leftType, op, rightType))
		return
	}

	// Crear temporal y generar cuádruplo
	tempVar := d.Directory.NewTempVar("bool")
	d.QuadQueue.Add(op, leftOperand, rightOperand, tempVar.MemoryAddress)

	d.OperandStack.Push(tempVar.MemoryAddress)
	d.TypeStack.Push(resultType)
}
