package builder

import (
	"BabyDuckCompiler/grammar"
	"BabyDuckCompiler/symbols"
	"fmt"
)

// DirectoryBuilder  inherits base listener generated by ANTRL
// Gets the main table of functions and variables
// Errors returns a list of semantic errors
// If true returns info for debug
type DirectoryBuilder struct {
	grammar.BaseBabyDuckListener
	Directory *symbols.FunctionDirectory
	Errors    []string
	Debug     bool
}

// NewDirectoryBuilder creates and initializes a new DirectoryBuilder
// Returns a pointer to the new directory
func NewDirectoryBuilder(debug bool) *DirectoryBuilder {
	return &DirectoryBuilder{
		Directory: symbols.NewFunctionDirectory(),
		Errors:    []string{},
		Debug:     debug,
	}
}

// EnterFunc obtains the name of the functions and the checks if it exists in the current scope
// Makes push to function name, now is in the scope
func (d *DirectoryBuilder) EnterFunc(ctx *grammar.FuncContext) {
	functionName := ctx.ID().GetText()

	// Recolectar parámetros
	var params []symbols.Variable
	if ctx.Param_list() != nil {
		paramListCtx := ctx.Param_list().(*grammar.Param_listContext)
		for _, paramCtx := range paramListCtx.AllParam() {
			param := paramCtx.(*grammar.ParamContext)
			varType := param.Type_().GetText()
			params = append(params, symbols.Variable{
				Type: varType,
			})
		}
	}

	err := d.Directory.AddFunction(functionName, params)
	if err != nil {
		d.Errors = append(d.Errors, err.Error())
	}

	// Agregar a scope
	d.Directory.CurrentScope = append(d.Directory.CurrentScope, functionName)
}

// ExitFunctionDeclaration pops out of the functions and returns to the scope before
func (d *DirectoryBuilder) ExitFunctionDeclaration(ctx *grammar.FuncContext) {
	d.Directory.CurrentScope = d.Directory.CurrentScope[:len(d.Directory.CurrentScope)-1]
}

// ExitVar_when exits a new declaration, tries to add every declaration to the current scope
// If it already existed saves the error
func (d *DirectoryBuilder) ExitVar_decl(ctx *grammar.Var_declContext) {
	variableType := ctx.Type_().GetText()

	for _, idNode := range ctx.Id_list().AllID() {
		variableName := idNode.GetText()
		err := d.Directory.AddVariable(variableName, variableType)
		if err != nil {
			// Variable already defined in current scope"
			d.Errors = append(d.Errors, err.Error())
		}
	}
}

// EnterParam when entering a new function tries to add it to the current scope
func (d *DirectoryBuilder) EnterParam(ctx *grammar.ParamContext) {
	paramName := ctx.ID().GetText()
	paramType := ctx.Type_().GetText()

	err := d.Directory.AddVariable(paramName, paramType)
	if err != nil {
		// Parameter already defined in current function
		d.Errors = append(d.Errors, err.Error())
	}
}

// ExitAssign checks that if you want to use a variable i wnt to make sure it was already declared
func (d *DirectoryBuilder) ExitAssign(ctx *grammar.AssignContext) {
	variableName := ctx.ID().GetText()
	scopes := d.Directory.CurrentScope

	err := d.Directory.ValidateVariable(scopes, variableName)
	if err != nil {
		d.Errors = append(d.Errors, err.Error())
	}
}

// ExitExpression
func (d *DirectoryBuilder) ExitExpression(ctx *grammar.ExpressionContext) {

	if ctx.Relational() != nil {
		left := ctx.Exp()
		right := ctx.Relational().Exp()

		d.validateExp(left)
		d.validateExp(right)
	}
}

func (d *DirectoryBuilder) validateExp(exp grammar.IExpContext) {
	if exp == nil {
		return
	}

	for _, term := range exp.AllTerm() {
		d.validateTerm(term)
	}
}

func (d *DirectoryBuilder) validateTerm(ctx grammar.ITermContext) {
	for _, factor := range ctx.AllFactor() {
		d.validateFactor(factor)
	}
}
func (d *DirectoryBuilder) validateFactor(ctx grammar.IFactorContext) {
	if ctx.Parexpr() != nil {
		d.validateExpression(ctx.Parexpr().Expression())
	} else if ctx.Factorsign() != nil {
		d.validateFactorsign(ctx.Factorsign())
	}
}

func (d *DirectoryBuilder) validateFactorsign(ctx grammar.IFactorsignContext) {
	val := ctx.Value()
	if val.ID() != nil {
		varName := val.ID().GetText()
		scopes := d.Directory.CurrentScope
		err := d.Directory.ValidateVariable(scopes, varName)
		if err != nil {
			d.Errors = append(d.Errors, fmt.Sprintf("variable '%s' is not declared", varName))
		}
	}
}

func (d *DirectoryBuilder) validateExpression(ctx grammar.IExpressionContext) {
	exp := ctx.Exp()
	if exp != nil {
		d.validateExp(exp)
	}

	rel := ctx.Relational()
	if rel != nil {
		d.validateRelational(rel)
	}
}

func (d *DirectoryBuilder) validateRelational(ctx grammar.IRelationalContext) {
	exp := ctx.Exp()
	if exp != nil {
		d.validateExp(exp)
	}
}

func (d *DirectoryBuilder) validateValue(ctx grammar.IValueContext) {
	id := ctx.ID()
	if id != nil {
		name := id.GetText()
		scopes := d.Directory.CurrentScope
		err := d.Directory.ValidateVariable(scopes, name)
		if err != nil {
			d.Errors = append(d.Errors, err.Error())
		}
	}
}

func (d *DirectoryBuilder) ExitPrint_stmt(ctx *grammar.Print_stmtContext) {
	for _, pexpr := range ctx.AllPrintexpr() {
		if pexpr.STRING() != nil {
			continue
		}

		exp := pexpr.Exp()
		if exp != nil {
			d.validateExp(exp)
		}
	}
}

func (d *DirectoryBuilder) ExitCycle(ctx *grammar.CycleContext) {
	if ctx.Expression() != nil {
		d.validateExpression(ctx.Expression())
	}
}
func (d *DirectoryBuilder) ExitCondition(ctx *grammar.ConditionContext) {
	cond := ctx.Expression()

	if cond != nil {
		d.validateExpression(cond)
	}
}

// ExitF_call checks if the function exists and if the number of arguments is correct
func (d *DirectoryBuilder) ExitF_call(ctx *grammar.F_callContext) {
	// Obtener el nombre de la función desde el contexto
	funcName := ctx.ID().GetText()

	// Obtener el número de argumentos
	numArgs := 0
	if ctx.Arg_list() != nil {
		// Recorrer todas las expresiones dentro de Arg_list
		for _ = range ctx.Arg_list().(*grammar.Arg_listContext).AllExpression() {
			numArgs++
		}
	}

	// Validar la llamada de la función con la cantidad de argumentos
	if err := d.Directory.ValidateFunctionCall(funcName, numArgs); err != nil {
		// Si hay un error en la validación, agregarlo a la lista de errores
		d.Errors = append(d.Errors, err.Error())
	}
}
