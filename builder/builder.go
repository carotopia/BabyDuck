package builder

import (
	"BabyDuckCompiler/grammar"
	"BabyDuckCompiler/quads"
	"BabyDuckCompiler/semantic"
	"BabyDuckCompiler/symbols"
	"fmt"
	"strconv"
)

// DirectoryBuilder  inherits base listener generated by ANTRL
// Gets the main table of functions and variables
// Errors returns a list of semantic errors
// If true returns info for debug
type DirectoryBuilder struct {
	grammar.BaseBabyDuckListener
	Directory *symbols.FunctionDirectory
	Errors    []string
	Debug     bool

	OperatorStack *quads.OperatorStack
	OperandStack  *quads.Stack
	TypeStack     *quads.Stack
	QuadQueue     *quads.QuadrupleQueue
}

// NewDirectoryBuilder creates and initializes a new DirectoryBuilder
// Returns a pointer to the new directory
func NewDirectoryBuilder(debug bool) *DirectoryBuilder {
	return &DirectoryBuilder{
		Directory:     symbols.NewFunctionDirectory(),
		Errors:        []string{},
		Debug:         debug,
		OperatorStack: quads.NewOperatorStack(),
		OperandStack:  quads.NewOperandStack(),
		TypeStack:     quads.NewStack(),
		QuadQueue:     quads.NewQuadrupleQueue(),
	}
}

// EnterFunc obtains the name of the functions and the checks if it exists in the current scope
// Makes push to function name, now is in the scope
func (d *DirectoryBuilder) EnterFunc(ctx *grammar.FuncContext) {
	functionName := ctx.ID().GetText()

	// Recolectar parámetros
	var params []symbols.Variable
	if ctx.Param_list() != nil {
		paramListCtx := ctx.Param_list().(*grammar.Param_listContext)
		for _, paramCtx := range paramListCtx.AllParam() {
			param := paramCtx.(*grammar.ParamContext)
			varType := param.Type_().GetText()
			params = append(params, symbols.Variable{
				Type: varType,
			})
		}
	}

	err := d.Directory.AddFunction(functionName, params)
	if err != nil {
		d.Errors = append(d.Errors, err.Error())
	}

	// Agregar a scope
	d.Directory.CurrentScope = append(d.Directory.CurrentScope, functionName)
}

// ExitFunctionDeclaration pops out of the functions and returns to the scope before
func (d *DirectoryBuilder) ExitFunctionDeclaration(ctx *grammar.FuncContext) {
	d.Directory.CurrentScope = d.Directory.CurrentScope[:len(d.Directory.CurrentScope)-1]
}

// ExitVar_when exits a new declaration, tries to add every declaration to the current scope
// If it already existed saves the error
func (d *DirectoryBuilder) ExitVar_decl(ctx *grammar.Var_declContext) {
	variableType := ctx.Type_().GetText()

	for _, idNode := range ctx.Id_list().AllID() {
		variableName := idNode.GetText()
		err := d.Directory.AddVariable(variableName, variableType)
		if err != nil {
			// Variable already defined in current scope"
			d.Errors = append(d.Errors, err.Error())
		}
	}
}

// EnterParam when entering a new function tries to add it to the current scope
func (d *DirectoryBuilder) EnterParam(ctx *grammar.ParamContext) {
	paramName := ctx.ID().GetText()
	paramType := ctx.Type_().GetText()

	err := d.Directory.AddVariable(paramName, paramType)
	if err != nil {
		// Parameter already defined in current function
		d.Errors = append(d.Errors, err.Error())
	}
}

// ExitAssign checks that if you want to use a variable i wnt to make sure it was already declared
func (d *DirectoryBuilder) ExitAssign(ctx *grammar.AssignContext) {
	variableName := ctx.ID().GetText()
	scopes := d.Directory.CurrentScope

	err := d.Directory.ValidateVariable(scopes, variableName)
	if err != nil {
		d.Errors = append(d.Errors, err.Error())
	}
}

// ExitExpression
func (d *DirectoryBuilder) ExitExpression(ctx *grammar.ExpressionContext) {

	if ctx.Relational() != nil {
		left := ctx.Exp()
		right := ctx.Relational().Exp()

		d.validateExp(left)
		d.validateExp(right)
	}
}

func (d *DirectoryBuilder) validateExp(exp grammar.IExpContext) {
	if exp == nil {
		return
	}

	for _, term := range exp.AllTerm() {
		d.validateTerm(term)
	}
}

func (d *DirectoryBuilder) validateTerm(ctx grammar.ITermContext) {
	for _, factor := range ctx.AllFactor() {
		d.validateFactor(factor)
	}
}
func (d *DirectoryBuilder) validateFactor(ctx grammar.IFactorContext) {
	if ctx.Parexpr() != nil {
		d.validateExpression(ctx.Parexpr().Expression())
	} else if ctx.Factorsign() != nil {
		d.validateFactorsign(ctx.Factorsign())
	}
}

func (d *DirectoryBuilder) validateFactorsign(ctx grammar.IFactorsignContext) {
	val := ctx.Value()
	if val.ID() != nil {
		varName := val.ID().GetText()
		scopes := d.Directory.CurrentScope
		err := d.Directory.ValidateVariable(scopes, varName)
		if err != nil {
			d.Errors = append(d.Errors, fmt.Sprintf("variable '%s' is not declared", varName))
		}
	}
}

func (d *DirectoryBuilder) validateExpression(ctx grammar.IExpressionContext) {
	exp := ctx.Exp()
	if exp != nil {
		d.validateExp(exp)
	}

	rel := ctx.Relational()
	if rel != nil {
		d.validateRelational(rel)
	}
}

func (d *DirectoryBuilder) validateRelational(ctx grammar.IRelationalContext) {
	exp := ctx.Exp()
	if exp != nil {
		d.validateExp(exp)
	}
}

func (d *DirectoryBuilder) validateValue(ctx grammar.IValueContext) {
	id := ctx.ID()
	if id != nil {
		name := id.GetText()
		scopes := d.Directory.CurrentScope
		err := d.Directory.ValidateVariable(scopes, name)
		if err != nil {
			d.Errors = append(d.Errors, err.Error())
		}
	}
}

func (d *DirectoryBuilder) ExitPrint_stmt(ctx *grammar.Print_stmtContext) {
	for _, pexpr := range ctx.AllPrintexpr() {
		if pexpr.STRING() != nil {
			continue
		}

		exp := pexpr.Exp()
		if exp != nil {
			d.validateExp(exp)
		}
	}
}

func (d *DirectoryBuilder) ExitCycle(ctx *grammar.CycleContext) {
	if ctx.Expression() != nil {
		d.validateExpression(ctx.Expression())
	}
}
func (d *DirectoryBuilder) ExitCondition(ctx *grammar.ConditionContext) {
	cond := ctx.Expression()

	if cond != nil {
		d.validateExpression(cond)
	}
}

// ExitF_call checks if the function exists and if the number of arguments is correct
func (d *DirectoryBuilder) ExitF_call(ctx *grammar.F_callContext) {
	// Obtener el nombre de la función desde el contexto
	funcName := ctx.ID().GetText()

	// Obtener el número de argumentos
	numArgs := 0
	if ctx.Arg_list() != nil {
		// Recorrer todas las expresiones dentro de Arg_list
		for _ = range ctx.Arg_list().(*grammar.Arg_listContext).AllExpression() {
			numArgs++
		}
	}

	// Validar la llamada de la función con la cantidad de argumentos
	if err := d.Directory.ValidateFunctionCall(funcName, numArgs); err != nil {
		// Si hay un error en la validación, agregarlo a la lista de errores
		d.Errors = append(d.Errors, err.Error())
	}
}

func (d *DirectoryBuilder) ExitFactor(ctx *grammar.FactorContext) {
	// case 1: paréntesis (la expresión ya habrá empujado su resultado)
	if ctx.Parexpr() != nil {
		return
	}
	// case 2: signo y valor
	fs := ctx.Factorsign()
	val := fs.Value().GetText()

	// Determinar si es constante int, float o variable
	if _, err := strconv.Atoi(val); err == nil {
		d.OperandStack.Push(val)
		d.TypeStack.Push("int")
	} else if _, err := strconv.ParseFloat(val, 64); err == nil {
		d.OperandStack.Push(val)
		d.TypeStack.Push("float")
	} else {
		// variable
		scope := d.Directory.CurrentScope[len(d.Directory.CurrentScope)-1]
		variable, exists := d.Directory.FindVariable(scope, val)
		if !exists {
			d.Errors = append(d.Errors, fmt.Sprintf("Variable '%s' no declarada", val))
			return
		}
		d.OperandStack.Push(val)
		d.TypeStack.Push(variable.Type)
	}
}

func (d *DirectoryBuilder) ExitTerm(ctx *grammar.TermContext) {
	if len(ctx.AllMulop()) > 0 {
		{
			op, _ := d.OperatorStack.Peek()
			if op == "*" || op == "/" {
				d.OperatorStack.Pop()

				right, _ := d.OperandStack.Pop()
				left, _ := d.OperandStack.Pop()

				rt, _ := d.TypeStack.Pop()
				rightType := rt.(string)
				lt, _ := d.TypeStack.Pop()
				leftType := lt.(string)

				resultType := semantic.Cube[op][leftType][rightType]
				if resultType == "" {
					d.Errors = append(d.Errors,
						fmt.Sprintf("Tipo incompatible: %s %s %s", leftType, op, rightType))
					return
				}

				// Simula una dirección temporal
				tempVar := d.Directory.NewTempVar("t")
				d.QuadQueue.Add(op, left, right, tempVar.MemoryAddress)

				d.OperandStack.Push(tempVar.MemoryAddress)
				d.TypeStack.Push(resultType)
			}
		}
	}
}

func (d *DirectoryBuilder) ExitExp(ctx *grammar.ExpContext) {
	if len(ctx.AllAddop()) > 0 {
		op, _ := d.OperatorStack.Peek()
		if op == "+" || op == "-" {
			d.OperatorStack.Pop()

			right, _ := d.OperandStack.Pop()
			left, _ := d.OperandStack.Pop()

			rt, _ := d.TypeStack.Pop()
			rightType := rt.(string)
			lt, _ := d.TypeStack.Pop()
			leftType := lt.(string)

			resultType := semantic.Cube[op][leftType][rightType]
			if resultType == "" {
				d.Errors = append(d.Errors,
					fmt.Sprintf("Tipo incompatible: %s %s %s", leftType, op, rightType))
				return
			}

			tempVar := d.Directory.NewTempVar("t")
			d.QuadQueue.Add(op, left, right, tempVar.MemoryAddress)

			d.OperandStack.Push(tempVar.MemoryAddress)
			d.TypeStack.Push(resultType)
		}
	}
}

func (d *DirectoryBuilder) ExitValue(ctx *grammar.ValueContext) {
	if ctx.ID() != nil {
		name := ctx.ID().GetText()

		variable, found := d.Directory.FindVariable(d.Directory.GetCurrentScope(), name)

		if !found {
			d.Errors = append(d.Errors, fmt.Sprintf("Variable '%s' no definida", name))
			return
		}

		d.OperandStack.Push(variable.MemoryAddress)
		d.TypeStack.Push(variable.Type)

	} else if ctx.Constant() != nil {
		val := ctx.Constant().GetText()
		typ := semantic.InferTypeFromConstant(val)

		// Aquí puedes manejar los constantes como literales directos
		d.OperandStack.Push(val)
		d.TypeStack.Push(typ)
	}
}

func (d *DirectoryBuilder) EnterTerm(ctx *grammar.TermContext) {
	if len(ctx.AllMulop()) > 0 {
		for _, op := range ctx.AllMulop() {
			d.OperatorStack.Push(op.GetText())
		}
	}
}
func (d *DirectoryBuilder) EnterExp(ctx *grammar.ExpContext) {
	if len(ctx.AllAddop()) > 0 {
		for _, op := range ctx.AllAddop() {
			d.OperatorStack.Push(op.GetText())
		}
	}

}

func (d *DirectoryBuilder) ExitProgram(ctx *grammar.ProgramContext) {
	fmt.Println("=== Cuádruplos generados ===")
	for i, quad := range d.QuadQueue.Items {
		fmt.Printf("%d: (%s, %v, %v, %v)\n", i, quad.Operator, quad.LeftOperand, quad.RightOperand, quad.Result)
	}
}
